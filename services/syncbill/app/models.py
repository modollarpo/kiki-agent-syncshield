"""
Database Models for SyncBillâ„¢

Tables:
1. invoices: Professional invoices generated from SyncLedger success fees
2. invoice_line_items: Itemized breakdown of invoice charges
3. payments: Payment records from Stripe/bank transfers
4. credit_memos: Credits issued for rollbacks/underperformance
5. tax_jurisdictions: Tax rates by country/state
6. payment_methods: Stored payment methods (Stripe)
"""

from datetime import datetime, timedelta
from decimal import Decimal
from typing import Optional
import uuid

from sqlalchemy import (
    Column, Integer, String, Numeric, DateTime, Boolean, 
    Text, ForeignKey, JSON, Index, UniqueConstraint
)
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import UUID

from app.database import Base
from app.config import settings


class Invoice(Base):
    """
    Professional invoices generated from SyncLedger success fee calculations.
    
    Flow:
    1. SyncLedger sends "SettlementPeriodClosed" event
    2. SyncBill fetches success fee details via gRPC
    3. Generate Invoice record
    4. Create Stripe invoice
    5. Send PDF to client
    """
    __tablename__ = "invoices"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    invoice_number = Column(String(50), unique=True, nullable=False, index=True)
    
    # Client identification
    store_id = Column(Integer, nullable=False, index=True)
    platform = Column(String(50), nullable=False)  # shopify, woocommerce, etc.
    customer_name = Column(String(255), nullable=False)
    customer_email = Column(String(255), nullable=False)
    
    # Billing period (matches SyncLedger settlement)
    billing_month = Column(Integer, nullable=False)  # 1-12
    billing_year = Column(Integer, nullable=False)   # 2026, etc.
    billing_period_start = Column(DateTime, nullable=False)
    billing_period_end = Column(DateTime, nullable=False)
    
    # Financial summary (from SyncLedger)
    baseline_revenue = Column(Numeric(12, 2), nullable=False)
    actual_revenue = Column(Numeric(12, 2), nullable=False)
    incremental_revenue = Column(Numeric(12, 2), nullable=False)
    uplift_percentage = Column(Numeric(5, 2), nullable=False)
    
    # Ad Spend Summary (NEW - Net Profit Model)
    baseline_ad_spend = Column(Numeric(12, 2), default=0.0, nullable=False)  # Historical avg monthly ad spend
    actual_ad_spend = Column(Numeric(12, 2), default=0.0, nullable=False)    # Actual ad spend this month (Meta + Google)
    incremental_ad_spend = Column(Numeric(12, 2), default=0.0, nullable=False)  # Actual - Baseline
    ad_spend_uplift_percent = Column(Numeric(5, 2), default=0.0)  # (Incremental / Baseline) * 100
    
    # Net Profit Calculation (THE KEY METRIC)
    net_profit_uplift = Column(Numeric(12, 2), default=0.0, nullable=False)  # IncrementalRevenue - IncrementalAdSpend
    baseline_profit = Column(Numeric(12, 2), default=0.0)  # BaselineRevenue - BaselineAdSpend
    actual_profit = Column(Numeric(12, 2), default=0.0)    # ActualRevenue - ActualAdSpend
    net_profit_uplift_percent = Column(Numeric(5, 2), default=0.0)  # (NetUplift / BaselineProfit) * 100
    
    # Client Value (NEW)
    client_net_gain = Column(Numeric(12, 2), default=0.0)  # NetProfitUplift - Subtotal (success fee)
    client_roi = Column(Numeric(5, 2), default=0.0)  # ClientNetGain / Subtotal
    
    # Invoice amounts
    subtotal = Column(Numeric(12, 2), nullable=False)  # Success fee before tax
    tax_rate = Column(Numeric(5, 4), default=0.0)      # 0.20 for 20% VAT
    tax_amount = Column(Numeric(12, 2), default=0.0)
    total_amount = Column(Numeric(12, 2), nullable=False)
    currency = Column(String(3), default="USD")
    
    # Payment tracking
    status = Column(
        String(20), 
        nullable=False, 
        default="draft"
    )  # draft, sent, viewed, paid, overdue, cancelled, credited
    
    payment_status = Column(
        String(20),
        nullable=False,
        default="unpaid"
    )  # unpaid, partial, paid, refunded
    
    amount_paid = Column(Numeric(12, 2), default=0.0)
    amount_due = Column(Numeric(12, 2), nullable=False)
    
    # Dates
    issue_date = Column(DateTime, nullable=False, default=datetime.utcnow)
    due_date = Column(DateTime, nullable=False)
    sent_at = Column(DateTime)
    viewed_at = Column(DateTime)
    paid_at = Column(DateTime)
    
    # Stripe integration
    stripe_invoice_id = Column(String(255), unique=True, index=True)
    stripe_customer_id = Column(String(255), index=True)
    hosted_invoice_url = Column(Text)  # Stripe-hosted payment page
    invoice_pdf = Column(Text)          # Stripe PDF URL
    
    # Custom PDF (generated by SyncBill)
    custom_pdf_path = Column(Text)  # Local/S3 storage path
    custom_pdf_url = Column(Text)   # Public download URL
    
    # XAI breakdown
    attribution_stats = Column(JSON)  # {"high_confidence": 60, "medium": 15}
    top_agents = Column(JSON)         # {"SyncFlow": 0.45, "SyncEngage": 0.30}
    top_conversions = Column(JSON)    # Top 10 orders KIKI influenced
    
    # Tax jurisdiction
    tax_country = Column(String(2))    # ISO country code (US, GB, DE)
    tax_state = Column(String(50))     # For US state tax
    tax_jurisdiction_id = Column(Integer, ForeignKey("tax_jurisdictions.id"))
    
    # Credit memos
    has_credits_applied = Column(Boolean, default=False)
    credits_applied = Column(Numeric(12, 2), default=0.0)
    
    # Notes
    notes = Column(Text)  # Internal notes
    customer_notes = Column(Text)  # Shown on invoice
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    created_by = Column(String(50), default="system")
    
    # Relationships
    line_items = relationship("InvoiceLineItem", back_populates="invoice", cascade="all, delete-orphan")
    payments = relationship("Payment", back_populates="invoice")
    credits = relationship("CreditMemo", back_populates="invoice")
    
    # Indexes
    __table_args__ = (
        Index('idx_invoice_store_billing', 'store_id', 'billing_year', 'billing_month'),
        Index('idx_invoice_status', 'status', 'payment_status'),
    )
    
    def __repr__(self):
        return f"<Invoice {self.invoice_number} - {self.customer_name} - ${self.total_amount}>"
    
    @property
    def is_overdue(self) -> bool:
        """Check if invoice is overdue"""
        return (
            self.payment_status != "paid" and 
            self.due_date < datetime.utcnow()
        )
    
    def calculate_due_date(self):
        """Calculate due date (Net 30 from issue date)"""
        self.due_date = self.issue_date + timedelta(days=settings.invoice_due_days)


class InvoiceLineItem(Base):
    """
    Itemized breakdown of invoice charges.
    
    Example:
    - Line 1: "Success Fee (20% of $25,000 incremental revenue)" - $5,000
    - Line 2: "Credit applied for Jan 10 rollback" - ($500)
    - Line 3: "VAT (20%)" - $900
    """
    __tablename__ = "invoice_line_items"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    invoice_id = Column(Integer, ForeignKey("invoices.id"), nullable=False)
    
    line_number = Column(Integer, nullable=False)  # 1, 2, 3...
    description = Column(Text, nullable=False)
    quantity = Column(Numeric(10, 2), default=1.0)
    unit_price = Column(Numeric(12, 2), nullable=False)
    amount = Column(Numeric(12, 2), nullable=False)
    
    # Reference to source data
    item_type = Column(String(50), nullable=False)  # success_fee, credit, tax, adjustment
    reference_id = Column(String(255))  # SyncLedger invoice_id, credit_memo_id, etc.
    
    created_at = Column(DateTime, default=datetime.utcnow)
    
    # Relationship
    invoice = relationship("Invoice", back_populates="line_items")
    
    def __repr__(self):
        return f"<LineItem {self.line_number}: {self.description} - ${self.amount}>"


class Payment(Base):
    """
    Payment records from Stripe or manual bank transfers.
    
    Flow:
    1. Client pays via Stripe-hosted invoice page
    2. Stripe webhook: "invoice.paid"
    3. Create Payment record
    4. Update Invoice.payment_status = "paid"
    5. Notify SyncPortal to update client dashboard
    """
    __tablename__ = "payments"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    payment_reference = Column(String(100), unique=True, nullable=False, index=True)
    
    # Invoice link
    invoice_id = Column(Integer, ForeignKey("invoices.id"), nullable=False)
    store_id = Column(Integer, nullable=False, index=True)
    
    # Payment details
    amount = Column(Numeric(12, 2), nullable=False)
    currency = Column(String(3), default="USD")
    payment_method = Column(String(50), nullable=False)  # card, bank_transfer, ach, wire
    payment_date = Column(DateTime, nullable=False, default=datetime.utcnow)
    
    # Status
    status = Column(String(20), nullable=False, default="pending")  # pending, completed, failed, refunded
    
    # Stripe integration
    stripe_payment_intent_id = Column(String(255), unique=True, index=True)
    stripe_charge_id = Column(String(255))
    stripe_payment_method_id = Column(String(255))
    
    # Bank transfer details (if manual)
    bank_reference = Column(String(255))
    bank_transaction_id = Column(String(255))
    
    # Metadata
    notes = Column(Text)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    processed_by = Column(String(50), default="system")
    
    # Relationship
    invoice = relationship("Invoice", back_populates="payments")
    
    def __repr__(self):
        return f"<Payment {self.payment_reference} - ${self.amount} - {self.status}>"


class CreditMemo(Base):
    """
    Credits issued for rollbacks, underperformance, or disputes.
    
    Zero-Risk Policy Implementation:
    - If SyncShield rolls back a change that cost client money
    - If KIKI underperforms (negative uplift after invoice sent)
    - If client disputes attribution accuracy
    
    Example:
    - Jan 15: SyncBill issued invoice for $5,000 (based on $25k incremental)
    - Jan 20: SyncShield rollback caused $2,000 revenue loss
    - Jan 21: Auto-generate $400 credit memo (20% of $2k loss)
    - Feb invoice: Deduct $400 from new success fee
    """
    __tablename__ = "credit_memos"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    credit_number = Column(String(50), unique=True, nullable=False, index=True)
    
    # Link to original invoice (if applicable)
    invoice_id = Column(Integer, ForeignKey("invoices.id"))
    store_id = Column(Integer, nullable=False, index=True)
    
    # Credit amount
    credit_amount = Column(Numeric(12, 2), nullable=False)
    currency = Column(String(3), default="USD")
    
    # Reason
    reason_code = Column(String(50), nullable=False)  # rollback, underperformance, dispute, goodwill
    reason_description = Column(Text, nullable=False)
    
    # Source event
    trigger_event = Column(String(50))  # syncshield_rollback, manual_adjustment
    reference_id = Column(String(255))  # SyncShield rollback ID, support ticket ID
    
    # Status
    status = Column(String(20), nullable=False, default="draft")  # draft, issued, applied, cancelled
    
    # Application
    applied_to_invoice_id = Column(Integer, ForeignKey("invoices.id"))  # Future invoice where credit is used
    applied_at = Column(DateTime)
    
    # Dates
    issue_date = Column(DateTime, nullable=False, default=datetime.utcnow)
    expiry_date = Column(DateTime)  # Credits expire after 12 months
    
    # Stripe integration
    stripe_credit_note_id = Column(String(255), unique=True)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    created_by = Column(String(50), default="system")
    approved_by = Column(String(50))
    notes = Column(Text)
    
    # Relationships
    invoice = relationship("Invoice", back_populates="credits", foreign_keys=[invoice_id])
    
    def __repr__(self):
        return f"<CreditMemo {self.credit_number} - ${self.credit_amount} - {self.reason_code}>"


class TaxJurisdiction(Base):
    """
    Tax rates by country/state for automatic tax calculation.
    
    Examples:
    - US-CA: 7.25% sales tax
    - GB: 20% VAT
    - DE: 19% VAT
    - AU: 10% GST
    """
    __tablename__ = "tax_jurisdictions"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    
    # Jurisdiction
    country_code = Column(String(2), nullable=False)  # ISO 3166-1 alpha-2 (US, GB, DE)
    state_code = Column(String(10))  # For US states (CA, NY, TX)
    jurisdiction_name = Column(String(255), nullable=False)
    
    # Tax details
    tax_type = Column(String(20), nullable=False)  # vat, gst, sales_tax
    tax_rate = Column(Numeric(5, 4), nullable=False)  # 0.20 for 20%
    tax_number_required = Column(Boolean, default=False)  # Does client need tax ID?
    
    # Stripe tax code
    stripe_tax_code = Column(String(50))  # txcd_99999999 for Stripe Tax
    
    # Active status
    active = Column(Boolean, default=True)
    effective_date = Column(DateTime, nullable=False)
    end_date = Column(DateTime)
    
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    __table_args__ = (
        UniqueConstraint('country_code', 'state_code', 'effective_date', name='uq_tax_jurisdiction'),
    )
    
    def __repr__(self):
        return f"<TaxJurisdiction {self.jurisdiction_name} - {self.tax_rate * 100}% {self.tax_type}>"


class PaymentMethod(Base):
    """
    Stored payment methods from Stripe.
    
    Allows automatic charging for future invoices.
    """
    __tablename__ = "payment_methods"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    store_id = Column(Integer, nullable=False, index=True)
    
    # Stripe references
    stripe_payment_method_id = Column(String(255), unique=True, nullable=False)
    stripe_customer_id = Column(String(255), nullable=False)
    
    # Payment method details
    type = Column(String(20), nullable=False)  # card, us_bank_account, sepa_debit
    
    # Card details (if type=card)
    card_brand = Column(String(20))  # visa, mastercard, amex
    card_last4 = Column(String(4))
    card_exp_month = Column(Integer)
    card_exp_year = Column(Integer)
    
    # Bank account details (if type=us_bank_account)
    bank_name = Column(String(255))
    bank_last4 = Column(String(4))
    
    # Status
    is_default = Column(Boolean, default=False)
    active = Column(Boolean, default=True)
    
    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f"<PaymentMethod {self.type} - {self.card_brand} ****{self.card_last4}>"
