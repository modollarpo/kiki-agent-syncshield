package syncledger



























































































































































































































































}	return resp, err	attributionLatency.Observe(float64(duration.Milliseconds()))	log.Printf("gRPC %s | %s | %v", info.FullMethod, duration, err)	duration := time.Since(start)	resp, err := handler(ctx, req)	start := time.Now()) (interface{}, error) {	handler grpc.UnaryHandler,	info *grpc.UnaryServerInfo,	req interface{},	ctx context.Context,func loggingInterceptor(}	}		c.Next()		}			return			c.Abort()			c.JSON(403, gin.H{"error": "Invalid internal API key"})		if apiKey != expectedKey {		}			expectedKey = "dev-internal-key-change-in-production"		if expectedKey == "" {		expectedKey := os.Getenv("KIKI_INTERNAL_API_KEY")		apiKey := c.GetHeader("x-internal-api-key")	return func(c *gin.Context) {func authMiddleware() gin.HandlerFunc {}	return router	}		apiGroup.GET("/audit/:storeID", app.GetAuditTrailHandler(db))		// Audit trail export (immutable ledger)		apiGroup.GET("/attribution/live/:storeID", app.GetLiveAttributionHandler(db))		// Real-time attribution status		apiGroup.GET("/settlement/:storeID/:year/:month", app.GetSettlementReportHandler(db))		// Monthly settlement report		apiGroup.GET("/client/:storeID", app.GetClientLedgerHandler(db))		// Client Revenue Engine Room (for dashboard)	{	apiGroup.Use(authMiddleware())	apiGroup := router.Group("/api/v1/ledger")	// Dashboard API	router.GET("/metrics", gin.WrapH(promhttp.Handler()))	// Prometheus metrics	})		c.JSON(200, gin.H{"status": "healthy", "service": "syncledger"})	router.GET("/healthz", func(c *gin.Context) {	// Health check	})		c.Next()		}			return			c.AbortWithStatus(204)		if c.Request.Method == "OPTIONS" {		c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, x-internal-api-key")		c.Writer.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")		c.Writer.Header().Set("Access-Control-Allow-Origin", "*")	router.Use(func(c *gin.Context) {	// CORS middleware	router := gin.Default()	gin.SetMode(gin.ReleaseMode)func setupHTTPRouter(db *gorm.DB) *gin.Engine {}	return db, nil	sqlDB.SetConnMaxLifetime(time.Hour)	sqlDB.SetMaxOpenConns(100)	sqlDB.SetMaxIdleConns(10)	}		return nil, err	if err != nil {	sqlDB, err := db.DB()	// Set connection pool settings	}		return nil, err	if err != nil {	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})	}		dsn = "postgres://kiki:password@postgres:5432/kiki_ledger?sslmode=disable"	if dsn == "" {	dsn := os.Getenv("DATABASE_URL")func initDB() (*gorm.DB, error) {}	wg.Wait()	log.Println("âœ… SyncLedgerâ„¢ stopped gracefully")	grpcServer.GracefulStop()	log.Println("ðŸ›‘ Shutting down SyncLedgerâ„¢...")	<-quit	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)	quit := make(chan os.Signal, 1)	// Graceful shutdown	}()		}			log.Fatalf("âŒ HTTP server failed: %v", err)		if err := httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {		log.Println("ðŸ’š Health: http://localhost:8090/healthz")		log.Println("ðŸ“ˆ Metrics: http://localhost:8090/metrics")		log.Println("ðŸ“Š Dashboard API: http://localhost:8090/api/v1/ledger/client/{storeID}")		log.Printf("ðŸŒ HTTP server listening on %s", httpPort)		}			Handler: router,			Addr:    httpPort,		httpServer := &http.Server{		router := setupHTTPRouter(db)		defer wg.Done()	go func() {	// Start HTTP server for dashboard API and metrics	}()		}			log.Fatalf("âŒ gRPC server failed: %v", err)		if err := grpcServer.Serve(lis); err != nil {		log.Printf("ðŸ”Œ gRPC server listening on %s", grpcPort)		}			log.Fatalf("âŒ Failed to listen on %s: %v", grpcPort, err)		if err != nil {		lis, err := net.Listen("tcp", grpcPort)		defer wg.Done()	go func() {	wg.Add(2)	var wg sync.WaitGroup	// Start gRPC server in goroutine	reflection.Register(grpcServer)	// Register reflection for grpcurl	grpc_health_v1.RegisterHealthServer(grpcServer, healthServer)	healthServer := health.NewServer()	// Register health check	pb.RegisterSyncLedgerServiceServer(grpcServer, ledgerService)	ledgerService := app.NewLedgerService(db)	// Register SyncLedgerService	)		grpc.UnaryInterceptor(loggingInterceptor),	grpcServer := grpc.NewServer(	// Initialize gRPC server	log.Println("âœ… Database connected and migrated")	}		log.Fatalf("âŒ Failed to migrate database: %v", err)	); err != nil {		&models.SuccessFeeInvoice{},		&models.AttributionLog{},		&models.BaselineSnapshot{},		&models.LedgerEntry{},	if err := db.AutoMigrate(	// Auto-migrate database models	}		log.Fatalf("âŒ Failed to connect to database: %v", err)	if err != nil {	db, err := initDB()	// Initialize database	log.Println("ðŸš€ Starting SyncLedgerâ„¢ - Automated OaaS Auditor")func main() {}	prometheus.MustRegister(attributionLatency)	prometheus.MustRegister(successFeeCalculated)	prometheus.MustRegister(revenueAttributed)func init() {)	)		},			Buckets: prometheus.LinearBuckets(0, 5, 20), // 0-100ms in 5ms increments			Help:    "Latency of attribution calculations in milliseconds",			Name:    "syncledger_attribution_latency_ms",		prometheus.HistogramOpts{	attributionLatency = prometheus.NewHistogram(	)		[]string{"store_id"},		},			Help: "Total success fees calculated (20% of incremental)",			Name: "syncledger_success_fee_calculated_total",		prometheus.CounterOpts{	successFeeCalculated = prometheus.NewCounterVec(	)		[]string{"store_id", "platform"},		},			Help: "Total incremental revenue attributed to KIKI",			Name: "syncledger_revenue_attributed_total",		prometheus.CounterOpts{	revenueAttributed = prometheus.NewCounterVec(	// Prometheus metricsvar ()	httpPort = ":8090"	// HTTP server port (for dashboard API and health checks)	grpcPort = ":50053"	// gRPC server portconst ()	pb "syncledger/proto"	"syncledger/internal/models"	"syncledger/app"	"gorm.io/gorm"	"gorm.io/driver/postgres"	"google.golang.org/grpc/reflection"	"google.golang.org/grpc/health/grpc_health_v1"	"google.golang.org/grpc/health"	"google.golang.org/grpc"	"github.com/prometheus/client_golang/prometheus/promhttp"	"github.com/prometheus/client_golang/prometheus"	"github.com/gin-gonic/gin"	"time"	"syscall"	"sync"	"os/signal"	"os"	"net/http"	"net"	"log"	"fmt"	"context"import (package main