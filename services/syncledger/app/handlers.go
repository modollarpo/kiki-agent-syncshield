package app
































































































































































































































































































































}	return &s	}		return nil	if s == "" {func stringPtr(s string) *string {// Helper: String pointer}	}		Nanos:    nanos,		Units:    units,		Currency: "USD",	return &pb.Money{	nanos := int32((f - float64(units)) * 1e9)	units := int64(f)func floatToMoney(f float64) *pb.Money {// Helper: Convert float64 to protobuf Money}	return float64(m.Units) + float64(m.Nanos)/1e9	}		return 0.0	if m == nil {func moneyToFloat(m *pb.Money) float64 {// Helper: Convert protobuf Money to float64}	return response, nil	}		CounterfactualRevenue: floatToMoney(attrLog.CounterfactualRevenue),		ContributingAgents:    entry.AgentsInvolved, // JSON string		Explanation:           entry.AttributionReason,		SuccessFeeAmount:      floatToMoney(entry.SuccessFeeAmount),		IncrementalRevenue:    floatToMoney(entry.IncrementalRevenue),		Confidence:            entry.AttributionConfidence,		Attributed:            entry.AttributedToKIKI,		Success:               true,	response := &pb.OrderAttributionResponse{	s.db.Where("ledger_entry_id = ?", entry.ID).First(&attrLog)	var attrLog models.AttributionLog	// Get attribution log for detailed explanation	}		return nil, status.Errorf(codes.Internal, "Failed to fetch order: %v", err)		}			return nil, status.Errorf(codes.NotFound, "Order %d not found in ledger", req.OrderId)		if err == gorm.ErrRecordNotFound {	if err := s.db.Where("order_id = ?", req.OrderId).First(&entry).Error; err != nil {	var entry models.LedgerEntry	// Find ledger entry	log.Printf("ðŸ” GetOrderAttribution: Order %d", req.OrderId)) (*pb.OrderAttributionResponse, error) {	req *pb.OrderAttributionRequest,	ctx context.Context,func (s *LedgerService) GetOrderAttribution(// - XAI explainability reports// - Admin review panel// - Client dashboard ("Why was I charged for this order?")// Used by://// GetOrderAttribution retrieves the attribution details for a specific order}	return response, nil	}		HighConfidenceCount:  int32(highConfidenceCount),		AttributionStats:     attributionStats,		AttributedOrderCount: int32(attributedCount),		TotalOrdersReviewed:  int32(len(entries)),		SuccessFeeAmount:     floatToMoney(totalSuccessFees),		GrowthPercentage:     float32(upliftPercentage),		IncrementalRevenue:   floatToMoney(totalIncremental),		CurrentRevenue:       floatToMoney(totalRevenue),		BaselineRevenue:      floatToMoney(monthlyBaseline),		Success:              true,	response := &pb.SuccessFeeResponse{		monthlyBaseline, totalRevenue, upliftPercentage, totalSuccessFees)	log.Printf("ðŸ“Š Settlement: Baseline $%.2f â†’ Actual $%.2f (+%.1f%%), Fee $%.2f",	}		"medium_confidence":  int32(attributedCount - highConfidenceCount),		"high_confidence":    int32(highConfidenceCount),		"attributed_orders":  int32(attributedCount),		"total_orders":       int32(len(entries)),	attributionStats := map[string]int32{	// Build XAI attribution stats	}		upliftPercentage = ((totalRevenue - monthlyBaseline) / monthlyBaseline) * 100	if monthlyBaseline > 0 {	var upliftPercentage float64	// Calculate uplift percentage	monthlyBaseline := baseline.BaselineRevenue / 12.0	// Calculate monthly baseline (annual baseline / 12)	}		}			}				highConfidenceCount++			if entry.AttributionConfidence >= 0.85 {			totalSuccessFees += entry.SuccessFeeAmount			totalIncremental += entry.IncrementalRevenue			attributedCount++		if entry.AttributedToKIKI {		totalRevenue += entry.OrderAmount	for _, entry := range entries {	)		highConfidenceCount int		attributedCount    int		totalSuccessFees   float64		totalIncremental   float64		totalRevenue       float64	var (	// Aggregate metrics	}		return nil, status.Errorf(codes.Internal, "Failed to fetch entries: %v", err)		req.StoreId, startDate, endDate).Find(&entries).Error; err != nil {	if err := s.db.Where("store_id = ? AND created_at BETWEEN ? AND ?",	var entries []models.LedgerEntry	endDate := startDate.AddDate(0, 1, 0).Add(-time.Second)	startDate := time.Date(int(req.Year), time.Month(req.Month), 1, 0, 0, 0, 0, time.UTC)	// Get all ledger entries for this billing period	}		return nil, status.Errorf(codes.NotFound, "Baseline not found for store %d", req.StoreId)	if err := s.db.Where("store_id = ?", req.StoreId).First(&baseline).Error; err != nil {	var baseline models.BaselineSnapshot	// Get baseline		req.StoreId, req.Year, req.Month)	log.Printf("ðŸ“… CalculateSuccessFee: Store %d, Period %d-%02d",) (*pb.SuccessFeeResponse, error) {	req *pb.SuccessFeeRequest,	ctx context.Context,func (s *LedgerService) CalculateSuccessFee(// - Attribution breakdown (XAI)// - Success fee (20% of incremental)// - Total incremental revenue// - Baseline vs current revenue comparison// Returns://// - Client API for transparency// - Admin invoice generation script// - SyncPortal dashboard (end of month)// Called by://// CalculateSuccessFee generates the monthly OaaS settlement report}	return response, nil	}		Explanation:          decision.Reason,		InvoiceId:            "", // Set later when invoice is generated		LedgerEntryId:        int32(entry.ID),		SuccessFeeAmount:     floatToMoney(decision.SuccessFee),		CountedAsIncremental: decision.IsAttributed,		Success:              decision.IsAttributed,	response := &pb.IncrementalRevenueResponse{	// Build response		entry.ID, entry.IncrementalRevenue, entry.SuccessFeeAmount)	log.Printf("ðŸ’° Ledger Entry Created: ID %d, Incremental $%.2f, Fee $%.2f",	s.db.Create(attrLog)	}		AttributedBy:           "system",		CounterfactualRevenue:  decision.Counterfactual,		Explanation:            decision.Reason,		SyncEngageContribution: signalScores["nurture_engagement"],		SyncCreateContribution: signalScores["product_promotion"],		SyncFlowContribution:   signalScores["ad_touchpoint"],		ThresholdApplied:       s.calculator.ConfidenceThreshold,		FinalConfidence:        req.AttributionConfidence,		SignalScores:           internal.MarshalSignalScoresJSON(signalScores),		DecisionEngine:         "multi_signal_v1",		OrderID:                int(req.OrderId),		StoreID:                int(req.StoreId),		LedgerEntryID:          entry.ID,	attrLog := &models.AttributionLog{	// Create attribution log for transparency	s.db.Save(&baseline)	baseline.LastSyncedAt = time.Now()	}		baseline.TotalSuccessFees += decision.SuccessFee		baseline.TotalIncrementalRevenue += decision.IncrementalRevenue	if decision.FeeApplicable {	baseline.CurrentOrders += 1	baseline.CurrentRevenue += orderAmount	// Update baseline snapshot with current performance	}		return nil, status.Errorf(codes.Internal, "Failed to create ledger entry: %v", err)	if err := s.db.Create(entry).Error; err != nil {	// Save to database	}		InvoiceStatus:          "pending",		AgentsInvolved:         internal.MarshalAgentsJSON(decision.AgentsInvolved),		AttributionReason:      decision.Reason,		CampaignID:             stringPtr(req.CampaignId),		FeeApplicable:          decision.FeeApplicable,		SuccessFeeAmount:       decision.SuccessFee,		UpliftPercentage:       decision.UpliftPercentage,		BaselineRevenue:        baseline.BaselineAvgOrderValue,		IncrementalRevenue:     decision.IncrementalRevenue,		AttributionConfidence:  req.AttributionConfidence,		AttributedToKIKI:       decision.IsAttributed,		OrderAmount:            orderAmount,		PlatformOrderID:        req.PlatformOrderId,		OrderID:                int(req.OrderId),		Platform:               req.Platform,		StoreID:                int(req.StoreId),	entry := &models.LedgerEntry{	// Create ledger entry (immutable record)	)		signalScores,		req.AttributionConfidence,		baseline.BaselineAvgOrderValue,		orderAmount,	decision := s.calculator.CalculateAttribution(	}		"nurture_engagement":  0.2,		"product_promotion":   0.3,		"ad_touchpoint":       0.5, // From attribution engine	signalScores := map[string]float64{	// Build signal scores from request metadata		incrementalAmount := moneyToFloat(req.IncrementalAmount)	orderAmount := moneyToFloat(req.OrderAmount)	// Calculate attribution decision	}		return nil, status.Errorf(codes.Internal, "Failed to fetch baseline: %v", err)		}				"Baseline not found for store %d. Call UpdateBaselineMetrics first.", req.StoreId)			return nil, status.Errorf(codes.FailedPrecondition,		if err == gorm.ErrRecordNotFound {	if err := s.db.Where("store_id = ?", req.StoreId).First(&baseline).Error; err != nil {	var baseline models.BaselineSnapshot	// Get baseline snapshot for this store	}		return nil, status.Error(codes.InvalidArgument, "attribution_confidence must be between 0.0 and 1.0")	if req.AttributionConfidence < 0.0 || req.AttributionConfidence > 1.0 {	}		return nil, status.Error(codes.InvalidArgument, "store_id and order_id are required")	if req.StoreId == 0 || req.OrderId == 0 {	// Validate request		req.StoreId, req.OrderId, moneyToFloat(req.OrderAmount), req.AttributionConfidence)	log.Printf("ðŸ“Š RecordIncrementalRevenue: Store %d, Order %d, Amount $%.2f, Confidence %.2f",) (*pb.IncrementalRevenueResponse, error) {	req *pb.IncrementalRevenueRequest,	ctx context.Context,func (s *LedgerService) RecordIncrementalRevenue(// }//   "campaign_id": "campaign_123_meta"//   "attribution_confidence": 0.85,//   "incremental_amount": {"units": 29, "nanos": 990000000},//   "order_amount": {"units": 99, "nanos": 990000000},//   "order_id": 456,//   "store_id": 123,// {// Example Request://// 4. SyncLedger records entry and calculates success fee// 3. If confidence >= 0.70, call this method via gRPC// 2. Attribution engine calculates confidence (e.g., 0.85)// 1. SyncPortal webhook receives order// gRPC Flow://// RecordIncrementalRevenue is called by SyncPortal when an order is attributed to KIKI}	}		calculator: internal.NewUpliftCalculator(),		db:         db,	return &LedgerService{func NewLedgerService(db *gorm.DB) *LedgerService {// NewLedgerService creates a new gRPC service instance}	calculator *internal.UpliftCalculator	db         *gorm.DB	pb.UnimplementedSyncLedgerServiceServertype LedgerService struct {// LedgerService implements the gRPC SyncLedgerService)	pb "syncledger/proto"	"syncledger/internal/models"	"syncledger/internal"	"gorm.io/gorm"	"google.golang.org/grpc/status"	"google.golang.org/grpc/codes"	"time"	"log"	"fmt"	"context"import (package app